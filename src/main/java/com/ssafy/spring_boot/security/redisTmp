// 1. Redis ì„¤ì •
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        LettuceConnectionFactory factory = new LettuceConnectionFactory("localhost", 6379);
        factory.setDatabase(0);
        return factory;
    }

    @Bean
    public RedisTemplate<String, String> redisTemplate() {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory());
        template.setDefaultSerializer(new StringRedisSerializer());
        return template;
    }
}

// 2. Redis í† í° ê´€ë¦¬ ì„œë¹„ìŠ¤
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisTokenService {

    private final RedisTemplate<String, String> redisTemplate;
    private final TokenProvider tokenProvider;

    /**
     * ğŸ”¥ Redisì— ì‚¬ìš©ì í† í° ì •ë³´ ì €ì¥
     */
    public void storeUserTokens(Long userId, String accessToken, String refreshToken) {
        String userKey = "user_tokens:" + userId;

        Map<String, String> tokenData = new HashMap<>();
        tokenData.put("accessToken", accessToken);
        tokenData.put("refreshToken", refreshToken);
        tokenData.put("lastUpdate", String.valueOf(System.currentTimeMillis()));
        tokenData.put("authorities", tokenProvider.getAuthoritiesFromToken(accessToken));

        // Redis Hashë¡œ ì €ì¥ (7ì¼ TTL)
        redisTemplate.opsForHash().putAll(userKey, tokenData);
        redisTemplate.expire(userKey, 7, TimeUnit.DAYS);

        log.info("Redisì— ì‚¬ìš©ì {} í† í° ì €ì¥ ì™„ë£Œ", userId);
    }

    /**
     * Redisì—ì„œ ì‚¬ìš©ì Refresh Token ì¡°íšŒ
     */
    public String getRefreshToken(Long userId) {
        String userKey = "user_tokens:" + userId;
        return (String) redisTemplate.opsForHash().get(userKey, "refreshToken");
    }

    /**
     * Redisì—ì„œ ì‚¬ìš©ì Access Token ì¡°íšŒ
     */
    public String getAccessToken(Long userId) {
        String userKey = "user_tokens:" + userId;
        return (String) redisTemplate.opsForHash().get(userKey, "accessToken");
    }

    /**
     * ğŸš€ ìë™ í† í° ê°±ì‹  í•µì‹¬ ë©”ì„œë“œ
     */
    public String autoRefreshToken(Long userId) {
        String refreshToken = getRefreshToken(userId);

        if (refreshToken == null) {
            throw new IllegalStateException("ì €ì¥ëœ Refresh Tokenì´ ì—†ìŠµë‹ˆë‹¤.");
        }

        if (!tokenProvider.validateRefreshToken(refreshToken)) {
            // Refresh Tokenë„ ë§Œë£Œ â†’ ì¬ë¡œê·¸ì¸ í•„ìš”
            removeUserTokens(userId);
            throw new IllegalStateException("Refresh Tokenì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¬ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        }

        // ìƒˆë¡œìš´ í† í° ìƒì„±
        String email = tokenProvider.getEmailFromToken(refreshToken);
        String authorities = tokenProvider.getAuthoritiesFromToken(refreshToken);

        String newAccessToken = tokenProvider.createAccessToken(userId, email, authorities);
        String newRefreshToken = tokenProvider.createRefreshToken(userId, email, authorities);

        // Redis ì—…ë°ì´íŠ¸
        storeUserTokens(userId, newAccessToken, newRefreshToken);

        log.info("ì‚¬ìš©ì {} í† í° ìë™ ê°±ì‹  ì™„ë£Œ", userId);
        return newAccessToken;
    }

    /**
     * ì‚¬ìš©ì í† í° ì •ë³´ ì‚­ì œ (ë¡œê·¸ì•„ì›ƒ ì‹œ)
     */
    public void removeUserTokens(Long userId) {
        String userKey = "user_tokens:" + userId;
        redisTemplate.delete(userKey);
        log.info("ì‚¬ìš©ì {} í† í° ì •ë³´ ì‚­ì œ", userId);
    }

    /**
     * í† í° ë§Œë£Œ ì„ë°• í™•ì¸
     */
    public boolean isTokenExpiringSoon(String accessToken) {
        if (!tokenProvider.validateToken(accessToken)) {
            return true; // ì´ë¯¸ ë§Œë£Œë¨
        }

        long remainingTime = tokenProvider.getRemainingTime(accessToken);
        return remainingTime < 10 * 60 * 1000; // 10ë¶„ ë¯¸ë§Œ ë‚¨ìŒ
    }
}

// 3. ìë™ ê°±ì‹  í•„í„°
@Component
@RequiredArgsConstructor
@Slf4j
public class AutoRefreshTokenFilter extends OncePerRequestFilter {

    private final TokenProvider tokenProvider;
    private final RedisTokenService redisTokenService;
    private final CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {

        try {
            String accessToken = getJwtFromRequest(request);

            if (StringUtils.hasText(accessToken)) {

                // ğŸ”¥ ìë™ ê°±ì‹  ë¡œì§
                if (tokenProvider.validateToken(accessToken)) {
                    // í† í°ì´ ìœ íš¨í•˜ì§€ë§Œ ë§Œë£Œ ì„ë°•ì¸ì§€ í™•ì¸
                    if (redisTokenService.isTokenExpiringSoon(accessToken)) {
                        Long userId = tokenProvider.getUserIdFromToken(accessToken);

                        try {
                            // ìë™ ê°±ì‹  ì‹œë„
                            String newAccessToken = redisTokenService.autoRefreshToken(userId);

                            // ì‘ë‹µ í—¤ë”ì— ìƒˆ í† í° ì¶”ê°€
                            response.setHeader("X-New-Access-Token", newAccessToken);

                            log.info("í† í° ìë™ ê°±ì‹  ì„±ê³µ: ì‚¬ìš©ì {}", userId);

                            // ìƒˆ í† í°ìœ¼ë¡œ ì¸ì¦ ì²˜ë¦¬
                            processAuthentication(newAccessToken);
                        } catch (Exception e) {
                            log.error("í† í° ìë™ ê°±ì‹  ì‹¤íŒ¨: {}", e.getMessage());
                            // ê¸°ì¡´ í† í°ìœ¼ë¡œ ê³„ì† ì§„í–‰
                            processAuthentication(accessToken);
                        }
                    } else {
                        // í† í°ì´ ìœ íš¨í•˜ê³  ë§Œë£Œ ì„ë°•í•˜ì§€ ì•ŠìŒ
                        processAuthentication(accessToken);
                    }

                } else {
                    // Access Tokenì´ ë§Œë£Œë¨ â†’ ìë™ ê°±ì‹  ì‹œë„
                    try {
                        // ë§Œë£Œëœ í† í°ì—ì„œ ì‚¬ìš©ì ID ì¶”ì¶œ (ìœ„í—˜í•˜ì§€ë§Œ ê°€ëŠ¥)
                        Long userId = extractUserIdFromExpiredToken(accessToken);

                        if (userId != null) {
                            String newAccessToken = redisTokenService.autoRefreshToken(userId);

                            // ìƒˆ í† í°ìœ¼ë¡œ ì¸ì¦ ì²˜ë¦¬
                            processAuthentication(newAccessToken);

                            // í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ìƒˆ í† í° ì „ë‹¬
                            response.setHeader("X-New-Access-Token", newAccessToken);

                            log.info("ë§Œë£Œëœ í† í° ìë™ ê°±ì‹  ì„±ê³µ: ì‚¬ìš©ì {}", userId);
                        }
                    } catch (Exception e) {
                        log.error("ë§Œë£Œëœ í† í° ê°±ì‹  ì‹¤íŒ¨: {}", e.getMessage());
                        // ê°±ì‹  ì‹¤íŒ¨ ì‹œ 401 ì—ëŸ¬ë¡œ ì§„í–‰
                    }
                }
            }

        } catch (Exception e) {
            log.error("ìë™ í† í° ê°±ì‹  í•„í„° ì˜¤ë¥˜", e);
        }

        filterChain.doFilter(request, response);
    }

    private void processAuthentication(String accessToken) {
        try {
            Authentication authentication = tokenProvider.getAuthentication(accessToken);
            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (Exception e) {
            log.error("ì¸ì¦ ì²˜ë¦¬ ì‹¤íŒ¨", e);
        }
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    private Long extractUserIdFromExpiredToken(String expiredToken) {
        try {
            // ë§Œë£Œëœ í† í°ë„ íŒŒì‹± ê°€ëŠ¥ (ì„œëª…ì€ í™•ì¸ë¨)
            return tokenProvider.getUserIdFromToken(expiredToken);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/users/signup") ||
               path.startsWith("/api/users/login") ||
               path.startsWith("/api/users/refresh") ||
               path.startsWith("/swagger-ui/") ||
               path.startsWith("/v3/api-docs") ||
               path.equals("/hello");
    }
}

// 4. ì—…ë°ì´íŠ¸ëœ UserServiceImpl (Redis ì—°ë™)
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class RedisUserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final RegionRepository regionRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenProvider tokenProvider;
    private final RedisTokenService redisTokenService;  // Redis ì„œë¹„ìŠ¤ ì¶”ê°€

    @Override
    @Transactional
    public LoginResponseDTO jwtLogin(LoginRequestDTO loginRequest) {
        log.debug("JWT ë¡œê·¸ì¸ ì‹œë„: {}", loginRequest.getEmail());

        // 1. ì‚¬ìš©ì ì¡°íšŒ ë° ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
        User user = userRepository.findByEmail(loginRequest.getEmail())
                .orElseThrow(() -> new EntityNotFoundException("í•´ë‹¹ ì´ë©”ì¼ì„ ê°€ì§„ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤: " + loginRequest.getEmail()));

        if (!passwordEncoder.matches(loginRequest.getPassword(), user.getPassword())) {
            throw new IllegalArgumentException("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        }

        // 2. í† í° ìƒì„±
        String authorities = "ROLE_USER";
        String accessToken = tokenProvider.createAccessToken(user.getId().longValue(), user.getEmail(), authorities);
        String refreshToken = tokenProvider.createRefreshToken(user.getId().longValue(), user.getEmail(), authorities);

        // 3. ğŸ”¥ Redisì— í† í° ì €ì¥ (ìë™ ê°±ì‹ ì„ ìœ„í•´)
        redisTokenService.storeUserTokens(user.getId().longValue(), accessToken, refreshToken);

        log.debug("JWT ë¡œê·¸ì¸ ì„±ê³µ + Redis ì €ì¥: {}", user.getEmail());

        return LoginResponseDTO.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(tokenProvider.getAccessTokenValidityInMilliseconds() / 1000)
                .userId(user.getId().longValue())
                .nickname(user.getNickname())
                .email(user.getEmail())
                .temperature(user.getTemperature())
                .regionName(user.getRegion().getName())
                .build();
    }

    /**
     * ğŸš€ ë¡œê·¸ì•„ì›ƒ (Redisì—ì„œ í† í° ì‚­ì œ)
     */
    @Transactional
    public void logout(Long userId) {
        redisTokenService.removeUserTokens(userId);
        log.info("ì‚¬ìš©ì {} ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ", userId);
    }
}