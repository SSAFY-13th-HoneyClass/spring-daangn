# ğŸ” ë‹¹ê·¼ë§ˆì¼“ í´ë¡ ì½”ë”© 5ì£¼ì°¨ ë¯¸ì…˜ - JWT ì¸ì¦

## ğŸ“‹ TO DO LIST

1. **JWT ì¸ì¦(Authentication) ë°©ë²•ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ê¸°**
2. **ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰ ë° ê²€ì¦ ë¡œì§ êµ¬í˜„í•˜ê¸°**
3. **íšŒì›ê°€ì… ë° ë¡œê·¸ì¸ API êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°**
4. **í† í°ì´ í•„ìš”í•œ API 1ê°œ ì´ìƒ êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°**
5. **ë¦¬í”„ë ˆì‰¬ í† í° ë°œê¸‰ ë¡œì§ êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°**

---

## ğŸ“ˆ êµ¬í˜„ ë°œì „ ê³¼ì •

### ğŸ”„ **1ë‹¨ê³„: ê¸°ë³¸ JWT ì¸ì¦ êµ¬í˜„**

#### âŒ **AccessToken ì—†ì´ API í˜¸ì¶œ ì‹œ 401 ì—ëŸ¬**
![AccessToken ì—†ì´ API í˜¸ì¶œ ì—ëŸ¬](img/accesstokenì—†ì´%20api%20í˜¸ì¶œ%20ì—ëŸ¬.png)

**ë¬¸ì œì :**
- JWT í† í° ì—†ì´ ë³´í˜¸ëœ APIì— ì ‘ê·¼ ì‹œ ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ ë¶€ì¡±
- ë‹¨ìˆœí•œ 403 Forbidden ì‘ë‹µìœ¼ë¡œ ì›ì¸ íŒŒì•… ì–´ë ¤ì›€

**í•´ê²°:**
- Spring Securityì˜ AuthenticationEntryPoint ì»¤ìŠ¤í„°ë§ˆì´ì§•
- ëª…í™•í•œ í•œêµ­ì–´ ì—ëŸ¬ ë©”ì‹œì§€ ì œê³µ: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. JWT í† í°ì´ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

---

#### âœ… **AccessToken í¬í•¨ API í˜¸ì¶œ ì„±ê³µ**
![AccessToken í¬í•¨ API í˜¸ì¶œ ì„±ê³µ](img/accesstokení¬í•¨%20api%20í˜¸ì¶œ%20ì„±ê³µ.png)

**ê°œì„ ì‚¬í•­:**
- JWT í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ êµ¬ì¶• ì™„ë£Œ
- Bearer í† í°ì„ Authorization í—¤ë”ì— í¬í•¨í•˜ì—¬ API ì ‘ê·¼ ì„±ê³µ
- ì‚¬ìš©ìë³„ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ì œì–´ êµ¬í˜„

---

### ğŸ”„ **2ë‹¨ê³„: RefreshToken ì¿ í‚¤ ê¸°ë°˜ ë³´ì•ˆ ê°•í™”**

#### ğŸ”’ **ì´ì „: RefreshTokenì„ Response Bodyë¡œ ë°˜í™˜**
![RefreshToken Cookie ì´ì „ì˜ ë¡œê·¸ì¸](img/refreshtoken%20cookie%20ì´ì „ì˜%20ë¡œê·¸ì¸.png)

**ë¬¸ì œì :**
- RefreshTokenì´ Response Bodyì— ë…¸ì¶œë˜ì–´ ë³´ì•ˆ ìœ„í—˜
- í´ë¼ì´ì–¸íŠ¸ì—ì„œ RefreshTokenì„ ì§ì ‘ ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ë²ˆê±°ë¡œì›€
- XSS ê³µê²©ì— ì·¨ì•½í•œ êµ¬ì¡°

---

#### ğŸ›¡ï¸ **ì´í›„: RefreshTokenì„ HttpOnly ì¿ í‚¤ë¡œ ì„¤ì •**
![RefreshToken Cookie ì´í›„ì˜ ë¡œê·¸ì¸](img/refreshtoken%20cookie%20ì´í›„ì˜%20ë¡œê·¸ì¸.png)

**ë³´ì•ˆ ê°•í™” ë‚´ìš©:**
- **HttpOnly ì¿ í‚¤**: JavaScriptë¡œ ì ‘ê·¼ ë¶ˆê°€í•˜ì—¬ XSS ê³µê²© ë°©ì§€
- **Response Body ì •ë¦¬**: AccessTokenë§Œ ë°˜í™˜í•˜ì—¬ ì •ë³´ ë…¸ì¶œ ìµœì†Œí™”
- **ìë™ ì¿ í‚¤ ê´€ë¦¬**: ë¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì¿ í‚¤ë¥¼ ê´€ë¦¬

```javascript
// ì„¤ì •ëœ ì¿ í‚¤ ì†ì„±
Cookie refreshTokenCookie = new Cookie("refreshToken", refreshToken);
refreshTokenCookie.setHttpOnly(true);    // XSS ê³µê²© ë°©ì§€
refreshTokenCookie.setSecure(false);     // ê°œë°œ: false, í”„ë¡œë•ì…˜: true
refreshTokenCookie.setPath("/");         // ì „ì²´ ì‚¬ì´íŠ¸ì—ì„œ ì‚¬ìš©
refreshTokenCookie.setMaxAge(7 * 24 * 60 * 60); // 7ì¼
```

---

#### ğŸ”„ **ìë™ í† í° ì¬ë°œê¸‰ ì‹œìŠ¤í…œ**
![RefreshToken Cookieë¥¼ ì´ìš©í•œ AccessToken ì¬ë°œê¸‰](img/refreshtoken%20cookieë¥¼%20ì´ìš©í•œ%20accesstoken%20ì¬ë°œê¸‰.png)

**ìë™í™”ëœ í† í° ê´€ë¦¬:**
- **ì¿ í‚¤ ê¸°ë°˜ ì¸ì¦**: Request Body ì—†ì´ ì¿ í‚¤ì—ì„œ ìë™ìœ¼ë¡œ RefreshToken ì¶”ì¶œ
- **ë¬´ì¤‘ë‹¨ í† í° ê°±ì‹ **: ìƒˆë¡œìš´ AccessTokenê³¼ RefreshToken ìë™ ë°œê¸‰
- **ë³´ì•ˆ ê°•í™”**: ìƒˆë¡œìš´ RefreshTokenë„ HttpOnly ì¿ í‚¤ë¡œ ìë™ ì„¤ì •

**í† í° ì¬ë°œê¸‰ í”Œë¡œìš°:**
1. í´ë¼ì´ì–¸íŠ¸ê°€ `/api/auth/refresh` í˜¸ì¶œ (Body ì—†ìŒ)
2. ì„œë²„ê°€ ì¿ í‚¤ì—ì„œ RefreshToken ìë™ ì¶”ì¶œ
3. í† í° ê²€ì¦ í›„ ìƒˆë¡œìš´ AccessToken ìƒì„±
4. ìƒˆë¡œìš´ RefreshTokenì„ ì¿ í‚¤ë¡œ ìë™ ì„¤ì •
5. AccessTokenë§Œ Response Bodyë¡œ ë°˜í™˜

---

## 1ï¸âƒ£ JWT ì¸ì¦(Authentication) ë°©ë²•ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ê¸°

### ğŸ¯ ì¸ì¦ ë°©ì‹ ë¹„êµ ë¶„ì„

#### ğŸ“Œ JWT (JSON Web Token) ì¸ì¦

**JWTë€?**
- JSON ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ë³´ë¥¼ ì•ˆì „í•˜ê²Œ ì „ì†¡í•˜ê¸° ìœ„í•œ ì»´íŒ©íŠ¸í•˜ê³  ìì²´ í¬í•¨ëœ ë°©ì‹
- í—¤ë”(Header), í˜ì´ë¡œë“œ(Payload), ì„œëª…(Signature) ì„¸ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±
- Base64Urlë¡œ ì¸ì½”ë”©ë˜ì–´ URL-safeí•œ ë¬¸ìì—´ë¡œ í‘œí˜„

**JWT êµ¬ì¡°:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**JWT ì¸ì¦ ê³¼ì •:**
1. ì‚¬ìš©ìê°€ ë¡œê·¸ì¸ ìš”ì²­
2. ì„œë²„ì—ì„œ ì‚¬ìš©ì ì •ë³´ ê²€ì¦
3. ê²€ì¦ ì„±ê³µ ì‹œ JWT í† í° ìƒì„± ë° ë°˜í™˜
4. í´ë¼ì´ì–¸íŠ¸ëŠ” í† í°ì„ ì €ì¥í•˜ê³  API ìš”ì²­ ì‹œ í—¤ë”ì— í¬í•¨
5. ì„œë²„ì—ì„œ í† í° ê²€ì¦ í›„ ìš”ì²­ ì²˜ë¦¬

**ì•¡ì„¸ìŠ¤ í† í° vs ë¦¬í”„ë ˆì‹œ í† í°:**
- **ì•¡ì„¸ìŠ¤ í† í°**: ì§§ì€ ìœ íš¨ê¸°ê°„(1ì‹œê°„), API ìš”ì²­ ì‹œ ì‚¬ìš©
- **ë¦¬í”„ë ˆì‹œ í† í°**: ê¸´ ìœ íš¨ê¸°ê°„(7ì¼), ì•¡ì„¸ìŠ¤ í† í° ì¬ë°œê¸‰ ì‹œ ì‚¬ìš©

#### ğŸ“Œ ì„¸ì…˜/ì¿ í‚¤ ì¸ì¦

**ë™ì‘ ë°©ì‹:**
1. ì‚¬ìš©ì ë¡œê·¸ì¸ ì‹œ ì„œë²„ì—ì„œ ì„¸ì…˜ ìƒì„±
2. ì„¸ì…˜ IDë¥¼ ì¿ í‚¤ë¡œ í´ë¼ì´ì–¸íŠ¸ì— ì „ì†¡
3. í´ë¼ì´ì–¸íŠ¸ëŠ” ìš”ì²­ ì‹œ ì¿ í‚¤ë¥¼ ìë™ìœ¼ë¡œ í¬í•¨
4. ì„œë²„ì—ì„œ ì„¸ì…˜ IDë¡œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ

**íŠ¹ì§•:**
- ì„œë²„ì— ì„¸ì…˜ ì •ë³´ ì €ì¥ (ë©”ëª¨ë¦¬ ì‚¬ìš©)
- ë¸Œë¼ìš°ì €ê°€ ìë™ìœ¼ë¡œ ì¿ í‚¤ ê´€ë¦¬
- CSRF ê³µê²©ì— ì·¨ì•½í•  ìˆ˜ ìˆìŒ

#### ğŸ“Œ OAuth 2.0

**OAuthë€?**
- ì„œë“œíŒŒí‹° ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‚¬ìš©ìì˜ ì •ë³´ì— ì œí•œì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¸ì¦ í”„ë ˆì„ì›Œí¬
- Google, Facebook, GitHub ë“±ì˜ ì™¸ë¶€ ì„œë¹„ìŠ¤ë¥¼ í†µí•œ ë¡œê·¸ì¸

**OAuth 2.0 í”Œë¡œìš°:**
1. í´ë¼ì´ì–¸íŠ¸ê°€ ì¸ì¦ ì„œë²„ë¡œ ì‚¬ìš©ìë¥¼ ë¦¬ë‹¤ì´ë ‰íŠ¸
2. ì‚¬ìš©ìê°€ ì™¸ë¶€ ì„œë¹„ìŠ¤ì—ì„œ ë¡œê·¸ì¸
3. ì¸ì¦ ì„œë²„ì—ì„œ ì¸ì¦ ì½”ë“œ ë°œê¸‰
4. í´ë¼ì´ì–¸íŠ¸ê°€ ì¸ì¦ ì½”ë“œë¡œ ì•¡ì„¸ìŠ¤ í† í° ìš”ì²­
5. ì•¡ì„¸ìŠ¤ í† í°ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ì„œë²„ì— API ìš”ì²­

#### ğŸ“Œ ì¸ì¦ ë°©ì‹ ë¹„êµí‘œ

| íŠ¹ì§• | JWT | ì„¸ì…˜/ì¿ í‚¤ | OAuth 2.0 |
|------|-----|-----------|-----------|
| **ìƒíƒœ ê´€ë¦¬** | Stateless | Stateful | Stateless |
| **ì„œë²„ ë©”ëª¨ë¦¬** | ë¶ˆí•„ìš” | í•„ìš” | ë¶ˆí•„ìš” |
| **í™•ì¥ì„±** | ë†’ìŒ | ë‚®ìŒ | ë†’ìŒ |
| **ë³´ì•ˆ** | ì¤‘ê°„ | ë†’ìŒ | ë†’ìŒ |
| **êµ¬í˜„ ë³µì¡ë„** | ì¤‘ê°„ | ë‚®ìŒ | ë†’ìŒ |
| **ëª¨ë°”ì¼ ì§€ì›** | ìš°ìˆ˜ | ì œí•œì  | ìš°ìˆ˜ |

---

## 2ï¸âƒ£ ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰ ë° ê²€ì¦ ë¡œì§ êµ¬í˜„í•˜ê¸°

### ğŸ¯ êµ¬í˜„ ëª©í‘œ
JWT í† í°ì˜ ìƒì„±, ê²€ì¦, íŒŒì‹±ì„ ë‹´ë‹¹í•˜ëŠ” TokenProviderì™€ JWT ì¸ì¦ í•„í„°ë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

### âœ… TokenProvider í´ë˜ìŠ¤ êµ¬í˜„

```java
@Slf4j
@Component
public class TokenProvider implements InitializingBean {

    private static final String AUTHORITIES_KEY = "auth";
    private static final String BEARER_TYPE = "Bearer";
    private static final String AUTHORIZATION_HEADER = "Authorization";

    private final String secret;
    private final long accessTokenValidityInMilliseconds;
    private final long refreshTokenValidityInMilliseconds;

    private SecretKey key;

    public TokenProvider(
            @Value("${jwt.secret}") String secret,
            @Value("${jwt.access-token.expiration}") long accessTokenValidityInMilliseconds,
            @Value("${jwt.refresh-token.expiration}") long refreshTokenValidityInMilliseconds) {
        this.secret = secret;
        this.accessTokenValidityInMilliseconds = accessTokenValidityInMilliseconds;
        this.refreshTokenValidityInMilliseconds = refreshTokenValidityInMilliseconds;
    }

    @Override
    public void afterPropertiesSet() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    // HTTP ìš”ì²­ì—ì„œ í† í° ì¶”ì¶œ
    public String getAccessToken(HttpServletRequest request) {
        String bearerToken = request.getHeader(AUTHORIZATION_HEADER);
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(BEARER_TYPE)) {
            return bearerToken.substring(7);
        }
        return null;
    }

    // ì•¡ì„¸ìŠ¤ í† í° ìƒì„±
    public String createAccessToken(Long userId, Authentication authentication) {
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        long now = (new Date()).getTime();
        Date validity = new Date(now + this.accessTokenValidityInMilliseconds);

        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .claim(AUTHORITIES_KEY, authorities)
                .signWith(key, SignatureAlgorithm.HS512)
                .setExpiration(validity)
                .compact();
    }

    // ë¦¬í”„ë ˆì‹œ í† í° ìƒì„±
    public String createRefreshToken(Long userId) {
        long now = (new Date()).getTime();
        Date validity = new Date(now + this.refreshTokenValidityInMilliseconds);

        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .signWith(key, SignatureAlgorithm.HS512)
                .setExpiration(validity)
                .compact();
    }

    // í† í°ì—ì„œ ì‚¬ìš©ì ID ì¶”ì¶œ
    public String getTokenUserId(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.getSubject();
    }

    // í† í°ì—ì„œ Authentication ê°ì²´ ìƒì„±
    public Authentication getAuthentication(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();

        Collection<? extends GrantedAuthority> authorities =
                Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());

        UserDetails principal = new User(claims.getSubject(), "", authorities);

        return new UsernamePasswordAuthenticationToken(principal, token, authorities);
    }

    // ì•¡ì„¸ìŠ¤ í† í° ìœ íš¨ì„± ê²€ì¦
    public boolean validateAccessToken(String token) {
        try {
            Jwts.parser().verifyWith(key).build().parseSignedClaims(token);
            return true;
        } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
            log.info("ì˜ëª»ëœ JWT ì„œëª…ì…ë‹ˆë‹¤.");
        } catch (ExpiredJwtException e) {
            log.info("ë§Œë£Œëœ JWT í† í°ì…ë‹ˆë‹¤.");
        } catch (UnsupportedJwtException e) {
            log.info("ì§€ì›ë˜ì§€ ì•ŠëŠ” JWT í† í°ì…ë‹ˆë‹¤.");
        } catch (IllegalArgumentException e) {
            log.info("JWT í† í°ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
        return false;
    }
}
```

### âœ… JWT ì¸ì¦ í•„í„° êµ¬í˜„

```java
@Slf4j
@RequiredArgsConstructor
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenProvider tokenProvider;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        // 1. Request Headerì—ì„œ JWT í† í° ì¶”ì¶œ
        String token = tokenProvider.getAccessToken(request);

        // 2. validateTokenìœ¼ë¡œ í† í° ìœ íš¨ì„± ê²€ì‚¬
        if (StringUtils.hasText(token) && tokenProvider.validateAccessToken(token)) {
            try {
                // 3. í† í°ì´ ìœ íš¨í•  ê²½ìš° í† í°ì—ì„œ Authentication ê°ì²´ë¥¼ ê°€ì§€ê³  ì™€ì„œ SecurityContextì— ì €ì¥
                Authentication authentication = tokenProvider.getAuthentication(token);
                SecurityContextHolder.getContext().setAuthentication(authentication);
                log.debug("Security Contextì— '{}' ì¸ì¦ ì •ë³´ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤, uri: {}", 
                         authentication.getName(), request.getRequestURI());
            } catch (Exception e) {
                log.error("í† í° ì¸ì¦ ê³¼ì •ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {}", e.getMessage());
                SecurityContextHolder.clearContext();
            }
        } else {
            log.debug("ìœ íš¨í•œ JWT í† í°ì´ ì—†ìŠµë‹ˆë‹¤, uri: {}", request.getRequestURI());
        }

        filterChain.doFilter(request, response);
    }
}
```

### âœ… Spring Security ì„¤ì •

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtExceptionHandlerFilter jwtExceptionHandlerFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(corsConfigurer -> corsConfigurer.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(configurer -> configurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(requests -> requests
                        // ê³µê°œ ì—”ë“œí¬ì¸íŠ¸
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .requestMatchers("/actuator/**").permitAll()
                        // ì¸ì¦ì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸
                        .requestMatchers("/api/items/**").authenticated()
                        .requestMatchers("/api/users/**").authenticated()
                        .anyRequest().authenticated()
                );

        // JWT í•„í„° ì¶”ê°€
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        http.addFilterBefore(jwtExceptionHandlerFilter, JwtAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

## 3ï¸âƒ£ íšŒì›ê°€ì… ë° ë¡œê·¸ì¸ API êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°

### ğŸ¯ êµ¬í˜„ ëª©í‘œ
JWT ê¸°ë°˜ ì¸ì¦ì„ ìœ„í•œ íšŒì›ê°€ì…, ë¡œê·¸ì¸, í† í° ì¬ë°œê¸‰, ë¡œê·¸ì•„ì›ƒ APIë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

### âœ… AuthController êµ¬í˜„

```java
@Tag(name = "Authentication", description = "ì¸ì¦ ê´€ë ¨ API")
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/signup")
    public ResponseEntity<AuthDto.SignUpResponse> signUp(@RequestBody AuthDto.SignUpRequest request) {
        AuthDto.SignUpResponse response = authService.signUp(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PostMapping("/login")
    public ResponseEntity<AuthDto.LoginResponse> login(@RequestBody AuthDto.LoginRequest request) {
        AuthDto.LoginResponse response = authService.login(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthDto.RefreshTokenResponse> refreshToken(@RequestBody AuthDto.RefreshTokenRequest request) {
        AuthDto.RefreshTokenResponse response = authService.refreshToken(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(Authentication authentication) {
        Long userId = Long.parseLong(authentication.getName());
        authService.logout(userId);
        return ResponseEntity.ok().build();
    }
}
```

### âœ… AuthService ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§

```java
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AuthService {

    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenProvider tokenProvider;

    @Transactional
    public AuthDto.SignUpResponse signUp(AuthDto.SignUpRequest request) {
        // ì´ë©”ì¼ ì¤‘ë³µ ê²€ì‚¬
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new CustomException(ErrorCode.DUPLICATE_EMAIL);
        }

        // ë¹„ë°€ë²ˆí˜¸ ì•”í˜¸í™”
        String encodedPassword = passwordEncoder.encode(request.getPassword());

        // ì‚¬ìš©ì ì €ì¥
        User savedUser = userRepository.save(request.toEntity(encodedPassword));

        log.info("íšŒì›ê°€ì… ì™„ë£Œ: userId={}, email={}", savedUser.getUserId(), savedUser.getEmail());
        return AuthDto.SignUpResponse.from(savedUser);
    }

    @Transactional
    public AuthDto.LoginResponse login(AuthDto.LoginRequest request) {
        // ì‚¬ìš©ì ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        User user = userRepository.findByEmail(request.getEmail());
        if (user == null) {
            throw new CustomException(ErrorCode.USER_NOT_FOUND);
        }

        // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new CustomException(ErrorCode.INVALID_PASSWORD);
        }

        // Authentication ê°ì²´ ìƒì„±
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                String.valueOf(user.getUserId()),
                null,
                Collections.singletonList(new SimpleGrantedAuthority(user.getRole()))
        );

        // í† í° ìƒì„±
        String accessToken = tokenProvider.createAccessToken(user.getUserId(), authentication);
        String refreshToken = tokenProvider.createRefreshToken(user.getUserId());

        // ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥ ë˜ëŠ” ì—…ë°ì´íŠ¸
        saveOrUpdateRefreshToken(user.getUserId(), refreshToken);

        log.info("ë¡œê·¸ì¸ ì„±ê³µ: userId={}, email={}", user.getUserId(), user.getEmail());
        return AuthDto.LoginResponse.of(user, accessToken, refreshToken);
    }
}
```

### âœ… ì¸ì¦ ê´€ë ¨ DTO

```java
public class AuthDto {

    @Schema(description = "íšŒì›ê°€ì… ìš”ì²­ DTO")
    public static class SignUpRequest {
        private String email;
        private String password;
        private String name;
        private String nickname;
        private String phone;
        private String profile;

        public User toEntity(String encodedPassword) {
            return User.builder()
                    .email(this.email)
                    .password(encodedPassword)
                    .name(this.name)
                    .nickname(this.nickname)
                    .phone(this.phone)
                    .profile(this.profile)
                    .profileImgPath("/images/default.jpg")
                    .role("ROLE_USER")
                    .build();
        }
    }

    @Schema(description = "ë¡œê·¸ì¸ ì‘ë‹µ DTO")
    public static class LoginResponse {
        private Long userId;
        private String email;
        private String nickname;
        private String accessToken;
        private String refreshToken;
        private String tokenType;

        public static LoginResponse of(User user, String accessToken, String refreshToken) {
            return LoginResponse.builder()
                    .userId(user.getUserId())
                    .email(user.getEmail())
                    .nickname(user.getNickname())
                    .accessToken(accessToken)
                    .refreshToken(refreshToken)
                    .tokenType("Bearer")
                    .build();
        }
    }
}
```

---

## 4ï¸âƒ£ í† í°ì´ í•„ìš”í•œ API 1ê°œ ì´ìƒ êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°

### ğŸ¯ êµ¬í˜„ ëª©í‘œ
ì§€ë‚œì£¼ êµ¬í˜„í•œ ìƒí’ˆ(Item) ê´€ë ¨ APIë“¤ì„ JWT ì¸ì¦ì´ í•„ìš”í•˜ë„ë¡ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.

### âœ… ItemController JWT ì¸ì¦ ì ìš©

```java
@Slf4j
@RestController
@RequestMapping("/api/items")
@RequiredArgsConstructor
@Tag(name = "Item Management", description = "ë‹¹ê·¼ë§ˆì¼“ ì•„ì´í…œ ê´€ë¦¬ API")
public class ItemController {

    private final ItemService itemService;

    @PostMapping
    public ResponseEntity<ItemDto.DetailResponse> createItem(
            @RequestBody ItemDto.CreateRequest request,
            Authentication authentication) {
        Long currentUserId = Long.parseLong(authentication.getName());
        log.info("Creating new item with request: {} by user: {}", request, currentUserId);
        
        ItemDto.DetailResponse response = itemService.createItem(request, currentUserId);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteItem(
            @PathVariable("id") Long itemId,
            Authentication authentication) {
        Long currentUserId = Long.parseLong(authentication.getName());
        log.info("Deleting item with id: {} by user: {}", itemId, currentUserId);
        
        itemService.deleteItem(itemId, currentUserId);
        
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{id}")
    public ResponseEntity<ItemDto.DetailResponse> updateItem(
            @PathVariable("id") Long itemId,
            @RequestBody ItemDto.UpdateRequest request,
            Authentication authentication) {
        Long currentUserId = Long.parseLong(authentication.getName());
        log.info("Updating item with id: {} and request: {} by user: {}", itemId, request, currentUserId);
        
        ItemDto.DetailResponse response = itemService.updateItem(itemId, request, currentUserId);
        
        return ResponseEntity.ok(response);
    }
}
```

### âœ… ItemService ê¶Œí•œ ê²€ì¦ ë¡œì§

```java
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ItemService {

    @Transactional
    public ItemDto.DetailResponse createItem(ItemDto.CreateRequest request, Long currentUserId) {
        // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
        User user = userRepository.findById(currentUserId)
                .orElseThrow(() -> new IllegalArgumentException("User not found with id: " + currentUserId));
        
        // Post ì—”í‹°í‹° ìƒì„±
        Post post = Post.builder()
                .title(request.getTitle())
                .content(request.getContent())
                .status("AVAILABLE")
                .user(user)
                .build();

        Post savedPost = postRepository.save(post);
        return ItemDto.DetailResponse.from(savedPost);
    }

    @Transactional
    public void deleteItem(Long itemId, Long currentUserId) {
        Post post = postRepository.findById(itemId)
                .orElseThrow(() -> new ItemNotFoundException(itemId));
        
        // ê¶Œí•œ ê²€ì¦: í˜„ì¬ ì‚¬ìš©ìê°€ ì‘ì„±í•œ ê²Œì‹œë¬¼ì¸ì§€ í™•ì¸
        if (!post.getUser().getUserId().equals(currentUserId)) {
            throw new IllegalArgumentException("You can only delete your own items");
        }
        
        postRepository.delete(post);
    }

    @Transactional
    public ItemDto.DetailResponse updateItem(Long itemId, ItemDto.UpdateRequest request, Long currentUserId) {
        Post post = postRepository.findById(itemId)
                .orElseThrow(() -> new ItemNotFoundException(itemId));
        
        // ê¶Œí•œ ê²€ì¦: í˜„ì¬ ì‚¬ìš©ìê°€ ì‘ì„±í•œ ê²Œì‹œë¬¼ì¸ì§€ í™•ì¸
        if (!post.getUser().getUserId().equals(currentUserId)) {
            throw new IllegalArgumentException("You can only update your own items");
        }
        
        post.updatePost(request.getTitle(), request.getContent(), request.getStatus());
        return ItemDto.DetailResponse.from(post);
    }
}
```

### âœ… Security ì„¤ì • - URL íŒ¨í„´ ì¸ì¦

```java
.authorizeHttpRequests(requests -> requests
        // ê³µê°œ ì—”ë“œí¬ì¸íŠ¸
        .requestMatchers("/api/auth/**").permitAll()
        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
        // ì¸ì¦ì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸
        .requestMatchers("/api/items/**").authenticated()  // ì•„ì´í…œ ê´€ë ¨ APIëŠ” ì¸ì¦ í•„ìš”
        .requestMatchers("/api/users/**").authenticated()
        .anyRequest().authenticated()
);
```

---

## 5ï¸âƒ£ ë¦¬í”„ë ˆì‰¬ í† í° ë°œê¸‰ ë¡œì§ êµ¬í˜„í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ê¸°

### ğŸ¯ êµ¬í˜„ ëª©í‘œ
ì•¡ì„¸ìŠ¤ í† í°ì˜ ì§§ì€ ìœ íš¨ê¸°ê°„ì„ ë³´ì™„í•˜ê¸° ìœ„í•œ ë¦¬í”„ë ˆì‹œ í† í° ë©”ì»¤ë‹ˆì¦˜ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

### âœ… RefreshToken ì—”í‹°í‹°

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "refresh_tokens")
public class RefreshToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "token_id")
    private Long tokenId;

    @Column(name = "refresh_token", nullable = false, length = 500)
    private String refreshToken;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    public void updateRefreshToken(String refreshToken, LocalDateTime expiresAt) {
        this.refreshToken = refreshToken;
        this.expiresAt = expiresAt;
    }
}
```

### âœ… RefreshToken Repository

```java
@Repository
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    
    Optional<RefreshToken> findByUserId(Long userId);
    
    Optional<RefreshToken> findByRefreshToken(String refreshToken);
    
    void deleteByUserId(Long userId);
    
    void deleteByRefreshToken(String refreshToken);
}
```

### âœ… ë¦¬í”„ë ˆì‹œ í† í° ì¬ë°œê¸‰ ë¡œì§

```java
@Transactional
public AuthDto.RefreshTokenResponse refreshToken(AuthDto.RefreshTokenRequest request) {
    String refreshToken = request.getRefreshToken();

    // ë¦¬í”„ë ˆì‹œ í† í° ìœ íš¨ì„± ê²€ì‚¬
    if (!tokenProvider.validateRefreshToken(refreshToken)) {
        throw new CustomException(ErrorCode.INVALID_REFRESH_TOKEN);
    }

    // ì €ì¥ëœ ë¦¬í”„ë ˆì‹œ í† í° í™•ì¸
    RefreshToken storedRefreshToken = refreshTokenRepository.findByRefreshToken(refreshToken)
            .orElseThrow(() -> new CustomException(ErrorCode.REFRESH_TOKEN_NOT_FOUND));

    // ë§Œë£Œ ì‹œê°„ í™•ì¸
    if (storedRefreshToken.getExpiresAt().isBefore(LocalDateTime.now())) {
        refreshTokenRepository.delete(storedRefreshToken);
        throw new CustomException(ErrorCode.EXPIRED_REFRESH_TOKEN);
    }

    // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    User user = userRepository.findById(storedRefreshToken.getUserId())
            .orElseThrow(() -> new CustomException(ErrorCode.USER_NOT_FOUND));

    // ìƒˆë¡œìš´ í† í° ìƒì„±
    Authentication authentication = new UsernamePasswordAuthenticationToken(
            String.valueOf(user.getUserId()),
            null,
            Collections.singletonList(new SimpleGrantedAuthority(user.getRole()))
    );

    String newAccessToken = tokenProvider.createAccessToken(user.getUserId(), authentication);
    String newRefreshToken = tokenProvider.createRefreshToken(user.getUserId());

    // ìƒˆë¡œìš´ ë¦¬í”„ë ˆì‹œ í† í°ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    Date expirationDate = tokenProvider.getExpirationDateFromToken(newRefreshToken);
    storedRefreshToken.updateRefreshToken(newRefreshToken, 
            expirationDate.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDateTime());

    return AuthDto.RefreshTokenResponse.of(newAccessToken, newRefreshToken);
}
```

### âœ… ë¡œê·¸ì•„ì›ƒ ì‹œ ë¦¬í”„ë ˆì‹œ í† í° ì‚­ì œ

```java
@Transactional
public void logout(Long userId) {
    refreshTokenRepository.deleteByUserId(userId);
    log.info("ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ: userId={}", userId);
}
```

---

## ğŸ“Š JWT ì„¤ì • ì •ë³´

### âœ… application.yml ì„¤ì •

```yaml
jwt:
  secret: VlwEyVBsYt9V7zq57TejMnVUyzblYcfPQye08f7MGVA9XkHa
  access-token:
    expiration: 3600000  # 1ì‹œê°„ (ë°€ë¦¬ì´ˆ)
  refresh-token:
    expiration: 604800000  # 7ì¼ (ë°€ë¦¬ì´ˆ)
```

### âœ… ì˜ì¡´ì„± ì„¤ì • (build.gradle)

```gradle
// JWT ê´€ë ¨
implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
implementation 'io.jsonwebtoken:jjwt-impl:0.12.3'
implementation 'io.jsonwebtoken:jjwt-jackson:0.12.3'

// Spring Security Test
testImplementation 'org.springframework.security:spring-security-test'
```

---

## ğŸ§ª API í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

### âœ… 1. íšŒì›ê°€ì… í…ŒìŠ¤íŠ¸

**Request:**
```bash
curl -X POST http://localhost:8080/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "name": "í™ê¸¸ë™",
    "nickname": "ê¸¸ë™ì´",
    "phone": "010-1234-5678",
    "profile": "ì•ˆë…•í•˜ì„¸ìš”!"
  }'
```

**Expected Response:**
```json
{
  "userId": 1,
  "email": "test@example.com",
  "name": "í™ê¸¸ë™",
  "nickname": "ê¸¸ë™ì´",
  "createdAt": "2024-01-01T10:00:00"
}
```

### âœ… 2. ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸

**Request:**
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

**Expected Response:**
```json
{
  "userId": 1,
  "email": "test@example.com",
  "nickname": "ê¸¸ë™ì´",
  "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
  "tokenType": "Bearer"
}
```

**Response Headers (ì¿ í‚¤ ì„¤ì •):**
```
Set-Cookie: refreshToken=eyJhbGciOiJIUzUxMiJ9...; HttpOnly; Path=/; Max-Age=604800
```

**âš ï¸ ì¤‘ìš” ë³€ê²½ì‚¬í•­:**
- RefreshTokenì€ ë” ì´ìƒ Response Bodyì— í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤
- RefreshTokenì€ HttpOnly ì¿ í‚¤ë¡œ ìë™ ì„¤ì •ë©ë‹ˆë‹¤ (XSS ê³µê²© ë°©ì§€)

### âœ… 3. ì•„ì´í…œ ìƒì„± í…ŒìŠ¤íŠ¸ (JWT í† í° í•„ìš”)

**Request:**
```bash
curl -X POST http://localhost:8080/api/items \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {accessToken}" \
  -d '{
    "title": "ì•„ì´í° 14 íŒë‹ˆë‹¤",
    "content": "ê¹¨ë—í•˜ê²Œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì§ê±°ë˜ ì„ í˜¸"
  }'
```

**Expected Response:**
```json
{
  "itemId": 1,
  "title": "ì•„ì´í° 14 íŒë‹ˆë‹¤",
  "content": "ê¹¨ë—í•˜ê²Œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì§ê±°ë˜ ì„ í˜¸",
  "status": "AVAILABLE",
  "userId": 1,
  "nickname": "ê¸¸ë™ì´",
  "profileImgPath": "/images/default.jpg",
  "createdAt": "2024-01-01T10:00:00",
  "updatedAt": "2024-01-01T10:00:00"
}
```

### âœ… 4. í† í° ì¬ë°œê¸‰ í…ŒìŠ¤íŠ¸ (ì¿ í‚¤ ê¸°ë°˜)

**Request:**
```bash
curl -X POST http://localhost:8080/api/auth/refresh \
  -H "Content-Type: application/json" \
  --cookie "refreshToken=eyJhbGciOiJIUzUxMiJ9..."
```

**Expected Response:**
```json
{
  "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
  "tokenType": "Bearer"
}
```

**Response Headers (ìƒˆë¡œìš´ ì¿ í‚¤ ì„¤ì •):**
```
Set-Cookie: refreshToken=eyJhbGciOiJIUzUxMiJ9...; HttpOnly; Path=/; Max-Age=604800
```

**âš ï¸ ì¤‘ìš” ë³€ê²½ì‚¬í•­:**
- Request Bodyê°€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (ì¿ í‚¤ì—ì„œ ìë™ ì¶”ì¶œ)
- ìƒˆë¡œìš´ RefreshTokenì´ ì¿ í‚¤ë¡œ ìë™ ì„¤ì •ë©ë‹ˆë‹¤
- Response Bodyì—ëŠ” AccessTokenë§Œ í¬í•¨ë©ë‹ˆë‹¤

### âœ… 5. ë¡œê·¸ì•„ì›ƒ í…ŒìŠ¤íŠ¸

**Request:**
```bash
curl -X POST http://localhost:8080/api/auth/logout \
  -H "Authorization: Bearer {accessToken}"
```

**Expected Response:**
```
HTTP/1.1 200 OK
```

**Response Headers (ì¿ í‚¤ ì‚­ì œ):**
```
Set-Cookie: refreshToken=; HttpOnly; Path=/; Max-Age=0
```

**âš ï¸ ì¤‘ìš”ì‚¬í•­:**
- ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ RefreshToken ì‚­ì œ
- ë¸Œë¼ìš°ì € ì¿ í‚¤ì—ì„œ RefreshToken ì‚­ì œ (Max-Age=0)

### âœ… 6. í† í° ì—†ì´ ë³´í˜¸ëœ API ì ‘ê·¼ í…ŒìŠ¤íŠ¸

**Request:**
```bash
curl -X POST http://localhost:8080/api/items \
  -H "Content-Type: application/json" \
  -d '{
    "title": "ì•„ì´í° 14 íŒë‹ˆë‹¤",
    "content": "ê¹¨ë—í•˜ê²Œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
  }'
```

**Expected Response:**
```json
{
  "timestamp": "2025-06-13T11:46:10.709382Z",
  "status": 401,
  "error": "Unauthorized",
  "message": "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. JWT í† í°ì´ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
  "path": "/api/items"
}
```

### âœ… 7. ë¸Œë¼ìš°ì €ì—ì„œ ì¿ í‚¤ ê¸°ë°˜ í…ŒìŠ¤íŠ¸

**Swagger UI ì‚¬ìš© ì‹œ:**
1. **ë¡œê·¸ì¸ í›„ ìë™ ì¿ í‚¤ ì„¤ì •**: ë¸Œë¼ìš°ì € ê°œë°œì ë„êµ¬ â†’ Application â†’ Cookiesì—ì„œ `refreshToken` í™•ì¸
2. **í† í° ì¬ë°œê¸‰**: `/api/auth/refresh` í˜¸ì¶œ ì‹œ Request Body ì—†ì´ ì‹¤í–‰
3. **ìë™ ì¿ í‚¤ ê°±ì‹ **: ìƒˆë¡œìš´ RefreshTokenì´ ì¿ í‚¤ë¡œ ìë™ ì—…ë°ì´íŠ¸

**ë¸Œë¼ìš°ì € ê°œë°œì ë„êµ¬ì—ì„œ í™•ì¸ ê°€ëŠ¥í•œ ì •ë³´:**
- **ì¿ í‚¤ëª…**: `refreshToken`
- **HttpOnly**: `true` (JavaScriptë¡œ ì ‘ê·¼ ë¶ˆê°€)
- **Path**: `/`
- **Max-Age**: `604800` (7ì¼)

---

## ğŸ¯ ì£¼ìš” êµ¬í˜„ íŠ¹ì§•

### âœ… ë³´ì•ˆ ê°•í™”
1. **JWT ì„œëª… ê²€ì¦**: HMAC SHA-512 ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
2. **í† í° ë§Œë£Œ ì‹œê°„ ê´€ë¦¬**: ì•¡ì„¸ìŠ¤(1ì‹œê°„), ë¦¬í”„ë ˆì‹œ(7ì¼)
3. **ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´**: ë³¸ì¸ì´ ì‘ì„±í•œ ì•„ì´í…œë§Œ ìˆ˜ì •/ì‚­ì œ ê°€ëŠ¥
4. **ë¹„ë°€ë²ˆí˜¸ ì•”í˜¸í™”**: BCrypt í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©

### âœ… ì‚¬ìš©ì ê²½í—˜ ê°œì„ 
1. **ìë™ í† í° ê°±ì‹ **: ë¦¬í”„ë ˆì‹œ í† í°ì„ í†µí•œ ì›í™œí•œ ì„œë¹„ìŠ¤ ì´ìš©
2. **ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€**: ìƒí™©ë³„ ì ì ˆí•œ HTTP ìƒíƒœ ì½”ë“œì™€ ë©”ì‹œì§€
3. **Swagger UI**: API ë¬¸ì„œí™” ë° í…ŒìŠ¤íŠ¸ í™˜ê²½ ì œê³µ

### âœ… í™•ì¥ì„± ê³ ë ¤
1. **Stateless ì„¤ê³„**: ì„œë²„ í™•ì¥ì„± í–¥ìƒ
2. **ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì¹œí™”ì **: JWTë¥¼ í†µí•œ ì„œë¹„ìŠ¤ ê°„ ì¸ì¦ ì •ë³´ ê³µìœ 
3. **ëª¨ë°”ì¼ ì•± ì§€ì›**: í† í° ê¸°ë°˜ ì¸ì¦ìœ¼ë¡œ ë‹¤ì–‘í•œ í´ë¼ì´ì–¸íŠ¸ ì§€ì›

---

## ğŸ’¡ í•™ìŠµ í¬ì¸íŠ¸

### âœ… JWT vs ì„¸ì…˜ ì°¨ì´ì  ì´í•´
- **JWT**: Stateless, í™•ì¥ì„± ìš°ìˆ˜, ì„œë²„ ë©”ëª¨ë¦¬ ì ˆì•½
- **ì„¸ì…˜**: Stateful, ì„œë²„ ë¶€í•˜, ë³´ì•ˆì„± ë†’ìŒ

### âœ… í† í° ê´€ë¦¬ ì „ëµ
- **ì•¡ì„¸ìŠ¤ í† í°**: ì§§ì€ ìœ íš¨ê¸°ê°„ìœ¼ë¡œ ë³´ì•ˆì„± í™•ë³´
- **ë¦¬í”„ë ˆì‹œ í† í°**: ê¸´ ìœ íš¨ê¸°ê°„ìœ¼ë¡œ ì‚¬ìš©ì í¸ì˜ì„± ì œê³µ

### âœ… Spring Security í•„í„° ì²´ì¸
- **JWT í•„í„°**: í† í° ì¶”ì¶œ ë° ê²€ì¦
- **ì˜ˆì™¸ ì²˜ë¦¬ í•„í„°**: JWT ê´€ë ¨ ì˜ˆì™¸ ì²˜ë¦¬
- **ê¶Œí•œ ê²€ì¦**: URL íŒ¨í„´ë³„ ì ‘ê·¼ ê¶Œí•œ ì„¤ì •

### âœ… ì¸ì¦ê³¼ ì¸ê°€ì˜ ë¶„ë¦¬
- **ì¸ì¦(Authentication)**: ì‚¬ìš©ì ì‹ ì› í™•ì¸
- **ì¸ê°€(Authorization)**: ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ ê¶Œí•œ í™•ì¸

---

## ğŸ›¡ï¸ ë³´ì•ˆ ê°•í™” ë°œì „ ê³¼ì • ìš”ì•½

### **Phase 1: ê¸°ë³¸ JWT ì¸ì¦**
- âŒ **ë¬¸ì œ**: ë¶ˆëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ë¡œ ì‚¬ìš©ì ê²½í—˜ ì €í•˜
- âœ… **í•´ê²°**: ëª…í™•í•œ í•œêµ­ì–´ ì—ëŸ¬ ë©”ì‹œì§€ ì œê³µ

### **Phase 2: RefreshToken ë³´ì•ˆ ê°•í™”**
- âŒ **ì´ì „**: RefreshTokenì„ Response Bodyë¡œ ë…¸ì¶œ
- âœ… **ê°œì„ **: HttpOnly ì¿ í‚¤ë¡œ XSS ê³µê²© ë°©ì§€

### **Phase 3: ìë™í™”ëœ í† í° ê´€ë¦¬**
- âŒ **ì´ì „**: í´ë¼ì´ì–¸íŠ¸ì—ì„œ RefreshToken ì§ì ‘ ê´€ë¦¬
- âœ… **ê°œì„ **: ì„œë²„ì—ì„œ ì¿ í‚¤ ê¸°ë°˜ ìë™ í† í° ì¬ë°œê¸‰

### **ìµœì¢… ë³´ì•ˆ ì•„í‚¤í…ì²˜**
1. **ì´ì¤‘ í† í° ì „ëµ**: AccessToken(1ì‹œê°„) + RefreshToken(7ì¼)
2. **ì¿ í‚¤ ë³´ì•ˆ**: HttpOnly, Secure(í”„ë¡œë•ì…˜), SameSite ì •ì±…
3. **ë°ì´í„°ë² ì´ìŠ¤ ê²€ì¦**: RefreshToken ìœ íš¨ì„± ì´ì¤‘ ê²€ì¦
4. **ìë™ í† í° ìˆœí™˜**: ì¬ë°œê¸‰ ì‹œ ìƒˆë¡œìš´ RefreshToken ìƒì„±

ì´ë²ˆ ë¯¸ì…˜ì„ í†µí•´ JWT ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œì˜ ì „ì²´ì ì¸ êµ¬ì¡°ì™€ Spring Securityì˜ ì‘ë™ ì›ë¦¬ë¥¼ ì´í•´í•˜ê³ , **ë³´ì•ˆì„±ê³¼ ì‚¬ìš©ì ê²½í—˜ì„ ëª¨ë‘ ê³ ë ¤í•œ** ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì˜ ì¸ì¦ ì‹œìŠ¤í…œì„ êµ¬ì¶•í–ˆìŠµë‹ˆë‹¤. ğŸ‰ 