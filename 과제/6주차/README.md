# Docker

<br>

## 가상머신 vs 리눅스 컨테이너

### 1) 가상머신 (Virtual Machine)

- 하나의 물리적인 컴퓨터 위에 또다른 `가상의 컴퓨터(운영체제)`를 만들어 사용하는 기술

- 동작하는 방식?

  - Host OS 위에 `Hypervisor`라는 소프트웨어가 존재
  - **Hypervisor**는 물리적인 자원(CPU나 메모리)을 여러 가상 운영체제(Guest Os)에 나눠줌
  - 각 Guest OS는 완전히 독립적으로 동작함

> **Hypervisor?**

- 물리적인 하드웨어 자원을 가상 머신들에게 나눠주는 관리자 역할
- 커널 수준에서 각 OS가 필요한 자원을 요청하면, 하드웨어 자원을 조율하여 전달

-> 운영체제 자체를 통채로 띄우기 떄문에, **VM은 무겁고 느릴 수 있음**.

```
[하드웨어]
   ↓
[Host OS]
   ↓
[Hypervisor (가상화 관리자)]
   ↓          ↓          ↓
[VM1]      [VM2]      [VM3]
 Guest OS  Guest OS  Guest OS

```

- 특징
  - 설치 파일 용량 큼
  - 격리 수준 높음 (보안 good) 

<br>

### 2) 리눅스 컨테이너 (Linux Container)

- 운영체제를 가상화하는게 아니라, **프로세스만 격리해서 실행**
- VM과 다르게, 컨테이너는 **HOST OS의 커널을 공유**하면서 동작
- 그래서 빠르고, 가볍고, 자원 소모 적음

> **컨테이너가 뭔데?** -> 무언갈 담는 그릇

- 하나의 어플리케이션을 실행하기 위한 모든 환경 (코드, 라이브러리, 의존성 등)을 담은 독립된 공간

```
[하드웨어]
   ↓
[Host OS (Linux)]
   ↓
[Docker Engine]
   ↓        ↓        ↓
[컨테이너1] [컨테이너2] [컨테이너3]
  App + lib  App + lib  App + lib
```

<br>

- 특징
  - 무게가 매우 가벼움
  - 커널을 공유하지만, `namespace` 와 `cgroup` 으로 격리 (`프로세스 단위의 격리 환경`을 만듦) -> 성능 손실 거의 x
    
<br></br>

### namespace 와 cgroup (컨테이너 격리)

- `namespace`
  - 각 컨테이너가 서로 독립된 환경처럼 보이게 해주는 기술
  - 예를 들어, PID / 네트워크 / 파일시스템 등 분리

- `cgroup`
  - CPU, 메모리, 디스크 등의 자원 사용량을 제한
  - 어떤 컨테이너는 메모리 1GB 만 사용하게..

<br></br>

----------------------------------------

## 시스템 컨테이너 vs 어플리케이션 컨테이너

- 시스템 컨테이너 : 전체 운영체제 ㅈ기능을 포함하여 가상머신처럼 작동 (예. LXC)
- 애플리케이션 컨테이너 : 하나의 애플리케이션을 실행하는 데 최적화된 컨테이너 (Docker)


## 도커란?

> `도커(Docker)`란 컨테이너 기반의 가상화 기술을 이용해 **어플리케이션을 이미지로 패키징**하고, <br>
> 어떤 환경에서도 **동일하게 실행**할 수 있도록 도와주는 오픈소스 플랫폼.

  - `이미지` : 컨테이너를 만들기 위한 실행 파일 (레시피 같은 것)
  - `컨테이너` : 이미지로부터 실행되는 독립된 실행 환경 (진짜 실행되는 공간)


## 왜 도커를 써야할까?

- 내가 만든 코드를 다른 환경에서도 똑같이 실행하기 위해
- 배포할 때 OS 버전, JDK 버전, 라이브러리 설치 이런 환경 이슈를 없애려고
- 설치 / 배포 과정 단순화
- 자동화 배포 (CI/CD)에도 적합 !
- 도커 이미지 하나면 끝 -> 어떤 OS 든 동일하게 실행됨



<br>

## Docker의 구성요소

1. Docker Client

  - 터미널네서 도커 명령어를 입력하는 **사용자 인터페이스**
  - `CLI`


2. Docker Daemon

  - 도커의 엔진 역할 (백그라운드에서 실행됨)
  - 컨테이너 생성, 이미지 빌드, 네트워크 관리 등의 실제 작업을 처리


3. Docker Host

  - 이곳에서 컨테이너가 돌아가
  - Docker Daemon이 설치된 머신

4. Docker Regsitry

  - 도커 이미지를 저장하고 공유하는 저장소
    - Public: Docker Hub, Quay.io
    - Private: AWS ECR, GitHub Container Registry, 자체 서버

 <br></br>


 ### Docker 이미지

 - 컨테이너를 만들기 위한 실행 환경 템플릿
 - 읽기 전용
 - 여러 개의 `레이어`로 구성
 - Dockfile의 각 명령어가 하나의 레이어가 되어 이미지로 저장됨
 - 생성 방법 : `Dockfile` -> `docker build`
 - 직접 삭제 전까지 유지됨


### Docker 컨테이너

- 이미지를 실행할 인스턴스
- 이미지 + **쓰기 가능한 레이어(writable layer)** 로 구성
- 컨테이너에서 파일을 수정하면,
  - 원본 이미지는 변경되지 않고,
  - 수정사항은 writable layer에 저장됨
- 생성 방법 : `docker run`
- 종료하거나 삭제하면 사라짐 

<br>

### 컨테이너의 생명 주기

1. 이미지에서 `docker run` -> 컨테이너 시작
2. 컨테이너는 독립적인 프로세스로 동작
3. 컨테이너 종료 -> writable layer 는 남아있음
4. 컨테이너 삭제 -> writable layer 도 삭제됨

```
Dockerfile ──(docker build)──▶ Docker Image ──(docker run)──▶ Docker Container
```

 <br></br>

- 하나의 이미지 -> 여러 개의 컨테이너 생성 가능 (1:N 관계)


 ---------



 ## Dockerfile

 - 컨테이너를 만들기 위한 이미지를 자동으로 생성하는 설정 파일
 - 이미지 빌드할 때 `docker build` 명령어에 의해 실행됨

### 주요 명령어 

| 명령어          | 설명                                         |
| ------------ | ------------------------------------------ |
| `FROM`       | 어떤 베이스 이미지로부터 시작할지 지정 (필수)                 |
| `WORKDIR`    | 작업 디렉토리 지정 (없으면 루트에서 시작됨)                  |
| `COPY`       | 호스트 파일/디렉토리를 이미지 안으로 복사                    |
| `RUN`        | 이미지 빌드 시 실행할 쉘 명령어 (ex. `apt-get install`) |
| `CMD`        | 컨테이너가 실행될 때 기본으로 실행할 명령                    |
| `ENTRYPOINT` | CMD와 비슷하지만 덮어쓰기 방지 (실행 핵심 명령어 지정)          |
| `EXPOSE`     | 컨테이너가 사용하는 포트 표시 (실제 포트 개방은 `-p` 옵션)       |
| `ENV`        | 환경변수 설정 (예: `ENV JAVA_HOME /usr/java`)     |


### docker 명령어

| 명령어                                             | 설명                   |
| ----------------------------------------------- | -------------------- |
| `docker build -t [이미지명] .`                      | Dockerfile 기반 이미지 생성 |
| `docker run -d -p 8080:8080 --name [이름] [이미지명]` | 컨테이너 생성 및 실행         |
| `docker ps`                                     | 현재 실행 중인 컨테이너 목록     |
| `docker exec -it [컨테이너ID/이름] bash`              | 컨테이너 내부 접속           |
| `docker logs [컨테이너ID/이름]`                       | 컨테이너 로그 확인           |
| `docker stop [ID]` / `start [ID]`               | 정지 / 재시작             |
| `docker rm [ID]` / `docker rmi [이미지ID]`         | 컨테이너/이미지 삭제          |


## 포트 포워딩 (Port Fowarding)

- 내 컴퓨터의 포트와 Docker 컨테이너 안의 포트를 연결하는 것

### 왜 필요하지?

- DOcker 컨테이너 안에는 자체적으로 격리된 네트워크 환경이 있음
- 컨테이너 안에서 서비스를 열어도 그냥 외부에서 접속할 수 없음
- 그래서 내 컴퓨터의 포트와 컨테이너 안의 포트를 포워딩 해줘야,
- 브라우저에서 `localhost:포트번호`로 접속이 가능해짐


## Nginx

- 엔진엑스는 고성능 웹 서버 이자 리버스 프록시 서버

### 왜 쓰여?

- HTML, CSS, JS 같은 정적 파일을 클라이언트에세 빠르게 제공해줌
- Spring 같은 서버 없이도 웹 사이트 띄울 수 있음
- 리버스 프록시 가능
  - 사용자가 접근할 때 실제 백엔드 서버 대신 중간에서 요청을 받아 전달해줌
  - 보통 서버 앞단에 nginx를 둠
- 로드 밸런서 역할
  - 여러 개의 백엔드 서버에 트래픽을 자동으로 분산해줌



### 근데 왜 중간에서 요청을 받는게 (리버스 프록시) 좋은거지?

- 프록시 : `대리인`이라는 뜻
- 서버 앞에 놓여서 대신 요청을 받아주면 -> 서버의 실제 IP와 구조를 숨길 수 있음 -> 보안 강화
- 캐싱 기능 : 정적 리소스를 미리 저장해서 빠르게 응답 가능 -> 백엔드 서버 부담 줄임 -> 성능 향상
- 여러 서비스 통합 : 같은 도메인에서 다양항 서비스를 분리 운영 가능 -> Nginx에서 요청을 받아 적절한 내부 서버로 라우팅 해줌

  

  
