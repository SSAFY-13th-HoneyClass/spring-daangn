# ✅ 로그인 인증 방식 정리

로그인을 수행하면 인증이 완료되었다는 **‘통행증(credential)’**이 발급된다.  
이후에는 매 요청마다 로그인을 반복하지 않고, 이 통행증을 통해 사용자 권한을 확인하게 된다.

그럼 저장 방식과 인증 주체에 따라서 어떻게 통행증이 발급되고 관리되는지 살펴보자. 


---

## 🔹 통행증 저장 방식에 따른 분류

### 1. 세션 + 쿠키 방식
- 사용자 인증 정보를 서버 세션에 저장하고, 클라이언트에는 `sessionId`만 쿠키에 담아 보관한다.
- 클라이언트는 요청 시 쿠키에 저장된 `sessionId`를 서버에 전송하고, 서버는 이를 기반으로 세션에서 사용자 정보를 조회한다.
- **상태가 있는(stateful)** 방식이다.

### 2. JWT 방식
- 사용자 인증 정보를 자체적으로 JWT 토큰에 담아 클라이언트가 보관한다.
- 서버는 토큰을 디코딩해 사용자 정보와 권한을 확인하며, 별도의 세션 저장소가 필요 없다.
- **상태가 없는(stateless)** 방식이다.

---

### 🔐 주요 보안 의문점 및 대응 방안

### Q1. 쿠키에 있는 `sessionId`가 탈취되면 어떻게 되나? (세션 하이재킹)
**해결 방안**
- 세션 만료 시간을 짧게 설정
- 쿠키에 `HttpOnly`, `Secure`, `SameSite` 속성 적용
- IP 또는 User-Agent 등 클라이언트 정보와 매칭 검증
- 일정 주기로 세션 ID 재발급

---

### Q2. 세션 만료 시간이 짧으면 자주 로그인을 해야 하지 않나?
**해결 방안**
- `Remember-Me` 기능을 활용해 자동 로그인 유지
- 사용 중일 때 세션을 연장하는 `rolling session` 적용
- Access Token은 짧게, Refresh Token은 길게 설정하여 **토큰 방식과 혼합 운영**

---

### Q3. Refresh Token이 탈취되면 권한을 속일 수 있지 않나?
- 일반적으로 Refresh Token에는 권한 정보는 포함되지 않으며, 최소한의 사용자 식별자만 담는다.
- 서명(Signature)을 통해 위변조 여부를 검증할 수 있으며, 이로 인해 변조는 어렵다.
- 그러나 **탈취된 토큰은 정상이므로 위변조가 없어도 명의 도용이 가능하다.**

---

### Q4. 탈취된 토큰을 사용한 명의 도용은 어떻게 방지할 수 있나?
**해결 방안**
- 토큰을 `Secure Cookie`나 `Keychain/Keystore`와 같은 OS 기반 보안 저장소에 보관
- 토큰 사용 시 클라이언트 정보(IP, 디바이스 정보 등)와 함께 검증
- Refresh Token을 1회용으로 만들어 사용할 때마다 재발급 (Rotation 방식)
- 비정상 로그인 탐지 및 MFA(2단계 인증) 적용
- JWT Blacklist 적용을 통한 토큰 무효화 처리

---

## 🔍 인증 주체에 따른 분류

### 1. 서버 자체 인증 (ID/PW 로그인)
- 사용자가 입력한 아이디와 비밀번호를 DB에 저장된 정보와 비교하여 인증
- 인증에 성공하면 JWT 또는 세션 ID를 발급하여 클라이언트에 전달

### 2. OAuth 2.0 기반 외부 인증
- Google, Kakao, Naver 등 외부 인증 제공자를 통해 인증을 수행
- 일반적인 절차는 다음과 같다:

  1. 사용자가 외부 로그인을 요청
  2. 서버는 외부 인증 페이지(Google 등)로 리다이렉트
  3. 사용자가 외부 인증을 완료하면, 외부 서버는 `Authorization Code`를 서버에 전달
  4. 서버는 이 코드를 통해 외부 인증 서버에 `Access Token`을 요청
  5. 받은 토큰으로 사용자 정보를 외부 API에서 조회
  6. 사용자 정보를 바탕으로 자체 JWT 발급 또는 세션 생성

---
