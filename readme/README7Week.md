# CI / CD

## CI/C란?

CI/CD는 지속적인 통합(Continuous Integration), 지속적인 배포(Continuous Deployment)의 줄임말,
소프트웨어 개발과 배포를 자동화하는 프로세스 이다.

### CI (Continuous Integration) - 지속적 통합
- 목표 : 개발자들이 자주 코드를 통합하고, 자동으로 테스트 및 빌드를 수행하도록 하는 것

- CI 도입 효과
  - 버그 조기 발견
  - 팀 간 코드 통합 시간 절약
  - 빠른 피드백

### CD (Continuous Delivery, Continuous Deployment)
- Continuous Delivery (지속적 전달)
  - 자동화된 테스트/빌드 이후 운영 배포 전 단계까지 자동화
  - 배포는 사람이 수동으로 클릭해서 진행
  - 안정성과 릴리즈 관리에 집중
- Continuous Deployment(지속적 배포)
  - 테스트까지 통과하면 자동으로 운영 환경까지 배포
  - 실제 사용자에게 무중단 배포가 이루어짐
  - 철저한 테스트 자동화가 전제조건

## Jenkins 란?
- Junkins는 오픈소스 자동화 서버
- 주로 CI 용도로 많이 쓰이지만 DC도 가능, 코드가 변경될 떄마다 자동으로 빌드, 테스트, 배포를 수행해주는 서버

### Jenkins 핵심 개념
- Job(작업) - 하나의 빌드 단위, 프로젝트마다 Jenkins Job을 만듬
- Pipeline - 여러 작업을 순차적으로 실행하는 스크립트, 복잡한 워크플로 작성 가능
- 빌드 트리거 - Git push, PR, 일정 등 빌드 실행 조건 설정 가능
- 플러그인 시스템 - Git, Docker, Slack 연동 등 수천 개의 플러그인을 통해 확장 가능

### Jenkinsfile (파이프라인 구성 스크립트 예시)
```
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
        stage('Test') {
            steps {
                sh 'mvn test'
            }
        }
        stage('Deploy') {
            steps {
                sh 'scp target/*.jar ec2-user@my-server:/home/app'
            }
        }
    }
}
```

## GitHub Action
- Github 저장소 안에 직접 CI/CD 파이프라인을 작성-실행할 수 있는 GitHub 내장 워크플로 자동화 서비스

## Jenkins와 GitHub Actions 비교

| 구분              | **Jenkins**                             | **GitHub Actions**                                                  |
| --------------- | --------------------------------------- | ------------------------------------------------------------------- |
| **배포 형태**       | 100 % **셀프 호스팅** (온프레미스/클라우드 VM에 직접 설치) | **SaaS**(GitHub 클라우드) + 셀프 호스팅 러너 겸용                                |
| **파이프라인 언어**    | **Groovy DSL** 또는 GUI(프리스타일)            | **YAML**                                                            |
| **플러그인/마켓플레이스** | 1 800+ 플러그인, 자유로운 커스터마이징                | Marketplace(액션) 수 천 개, 단 플러그인 생태계는 Jenkins보다 작음 ([everhour.com][1]) |
| **시작 난이도**      | 서버 설치·운영 필요, 러닝커브 큼                     | GitHub repo에 YML 추가만 하면 바로 실행                                       |
| **확장성**         | Master/Agent 구조 – 에이전트 늘려 수평 확장         | 러너를 저장소/Org/Enterprise 단위로 추가                                       |
| **보안/컴플라이언스**   | 완전한 자체 인프라 제어(에어갭 환경 가능)                | GitHub 클라우드 의존(단, 기업 플랜+셀프 호스트로 보완 가능)                              |
| **주요 활용**       | 레거시 빌드, 복잡한 온프레미스 파이프라인, 극단적 커스터마이징     | GitHub 기반 프로젝트, 빠른 온보딩, 오픈소스/스타트업                                   |

## Jenkins 장단점

| ✅ 장점                                                                  | ❌ 단점                                                                                        |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| • 완전한 자유도 & 플러그인 생태계<br>• 온프레미스 / 하이브리드 인프라에 최적<br>• 10 년 넘은 대규모 커뮤니티 | • 설치·업그레이드·플러그인 호환 관리 부담<br>• UI/UX 올드, 러닝커브 높음<br>• 고가용성 구성을 직접 설계해야 함 ([everhour.com][1]) |

## GitHub Actions 장단점

| ✅ 장점                                                                                                                         | ❌ 단점                                                                                                          |
| ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| • GitHub 계정만 있으면 즉시 사용, 설정 파일만 커밋하면 끝<br>• 모던 UI, PR 체크와 자연스럽게 연결<br>• SaaS 인프라라서 서버 관리 無<br>• 재사용 워크플로, 매트릭스 등 신기능 빠르게 업데이트 | • GitHub 생태계에 종속(레포가 GitHub 밖이면 사용 불가)<br>• 플러그인 커스터마이징 한계<br>• 무료 유휴 분당 제한 및 과금 모델 고려 필요 ([spacelift.io][1]) |

## 선택 가이드
- GitHub Actions
  - 저장소가 이미 GitHub에 있고, 빠르게 CI/CD를 시작하고 싶을 떄
  - 서버 운영 부담 없이 SaaS 모델을 선호할 때
  - 오픈소스 프로젝트, 스타트업,소규모 조직

- Jenkins
  - 내부망 전용 빌드 서버가 필수인 보안,규제 산업
  - 플러그인, 스크립트를 깊게 커스터마이징해야하는 복잡한 워크플로
  - GitHub외의 GitLab, Bitbucket, 사내 Git 등 멀티 SCM 연동 필요

### ❓SaaS 모델 (Software as a Service)
- SaaS는 서비스형 소프트웨어를 의미
- 소프트웨어를 설치하지 않고, 인터넷을 통해 접속해서 사용하는 형태
- 우리가 사용중인 SaaS 서비스
  - Gmail, Google Docs, Notion, ChatGPT, Figma, Canva, GitHub 등,,,
  - 웹 브라우저만 있으면 사용 가능하고, 서버/설치/업데이트는 제공자가 알아서 해줌

### ❓워크플로 (Workflow)
- 워크플로는 일련의 작업 단계 (build -> test -> deploy 등)를 순서대로 자동화 한 것
- GitHub Actions 에서 `.github/workflows/main.yml` 같은 파일에 정의되는 자동화된 프로세스

# CD 핵심 기술
## Docker
- Docker는 애플리케이션을 컨테이너로 패키징해서 실행할 수 있게 해주는 도구

## Kubernetes
- 여러 개의 Docker 컨테이너를 자동으로 배포, 관리, 확장해주는 시스템

### 왜 필요한가?
- Docker로 앱을 배포하더라도 서버 1대에만 돌릴 수 있음
- 복잡한 실서비스에서는 많은 컨테이너가 필요함
- 이걸 사람이 일일이 배포/모니터링하면 비효율적 -> 쿠버네티스로 자동화

### Kubernetes의 역할

| 기능           | 설명                                  |
| ------------ | ----------------------------------- |
| 컨테이너 오케스트레이션 | 컨테이너 여러 개를 묶어서 관리 (자동 배치, 시작/중지)    |
| 서비스 복제 / 확장  | 트래픽 증가 시 자동으로 컨테이너 수 늘림 (scale out) |
| 장애 복구        | 죽은 컨테이너 자동 재시작                      |
| 로드 밸런싱       | 여러 컨테이너에 트래픽 분산                     |
| 롤링 배포 / 롤백   | 다운타임 없이 새 버전 배포 가능                  |

## Docker vs Kubernetes
| 항목     | Docker                                             | Kubernetes                    |
| ------ | -------------------------------------------------- | ----------------------------- |
| 역할     | 컨테이너 **패키징 & 실행** 도구                               | 컨테이너 **배포 & 운영 자동화** 도구       |
| 단독 사용  | 단일 앱 개발·테스트에 적합                                    | 대규모 서비스 운영에 적합                |
| 학습 난이도 | 비교적 쉬움                                             | 상대적으로 복잡함                     |
| 기능     | 컨테이너화, 이미지 빌드/배포                                   | 오토스케일링, 헬스체크, 롤백, 서비스 디스커버리 등 |
| 함께 사용  | 보통 Kubernetes도 **Docker 기반 컨테이너를 관리**함 (기반 도구로 사용) |                               |

🐳 Docker = 음식을 깔끔하게 포장하는 도시락 통

☸ Kubernetes = 그 도시락들을 배달하고, 관리하고, 고장나면 교체하는 자동화 로봇 시스템

## CI / CD 흐름 구분해보기
```java
[개발자가 GitHub에 코드 push]
        ⬇
===== ✅ CI 영역 (지속적 통합) =====
[GitHub Actions / Jenkins]
→ 빌드 (예: ./gradlew build)
→ 테스트 (예: ./gradlew test)
→ Docker 이미지 생성 (예: docker build)
→ 이미지 저장소(DockerHub/ECR)로 push

===== ✅ CD 영역 (지속적 배포/전달) =====
[CD 도구 또는 명령]
→ Kubernetes에 배포 요청 (예: kubectl apply)
→ 쿠버네티스가 해당 이미지로 앱 실행
→ 트래픽 분산, 롤링 업데이트, 복제 등 수행
```

## CI 상황들
| 상황                      | CI 했다고 말할 수 있을까?           |
| ----------------------- | -------------------------- |
| Git push 시 자동 빌드만 도는 상태 | ❌ 부족함 (CI의 절반도 안 함)        |
| 자동 빌드 + 린트 + 테스트 코드 실행  | ✅ CI의 핵심 구성 완성             |
| 테스트 코드 실패 시 푸시 거부       | 🔥 이상적인 CI 시스템 (강력한 품질 보장) |

# 롤링 배포 (Rolling Depolyment)란?
- 여러 서버(인스턴스)를 운영 중일 떄, 기존 인스턴스를 한번에 모두 교체하지 않고, 순차적으로 새 버전으로 교체하는 배포 방식
- 서버를 일부씩 나눠서 새 버전으로 점진적 교체
- 사용자는 서비스 중단 없이 계속 접속 가능(무중단 배포)
- 기존 서버 일부는 구버전, 일부는 신버전으로 버전 공존 상태

| 장점               | 단점                       |
| ---------------- | ------------------------ |
| ✅ 무중단 배포 가능      | ❌ 구버전·신버전 간 호환성 이슈 발생 가능 |
| ✅ 서버 추가 없이 순차 교체 | ❌ 배포 중 처리할 수 있는 트래픽 감소   |
| ✅ 중간 실패 시 롤백 쉬움  | ❌ 배포 속도 느림 (단계별 진행)      |

# Elastic Beanstalk(엘라스틱 빈스톡)
- CD(지속적 배포) 전략 중 하나
- Eastic Beanstalk은 AWS에서 제공하는 애플리케이션 자동화 서비스
- 코드만 올리면 서버 생성부터 배포, 스케일링, 모니터링까지 AWS가 알아서 해주는 서비스

| 구성 요소             | 자동 처리 내용                |
| ----------------- | ----------------------- |
| **EC2**           | 가상 서버 생성 및 설정           |
| **Load Balancer** | 여러 서버에 트래픽 분산           |
| **Auto Scaling**  | 트래픽 증가 시 자동으로 서버 늘림     |
| **CloudWatch**    | 로그, 상태 모니터링             |
| **배포 전략**         | 롤링 배포, 블루/그린 배포 등 설정 가능 |

## 추가로 대표적인 배포 방식에 대하여 알아보자
| 배포 전략                          | 설명                           | 특징                |
| ------------------------------ | ---------------------------- | ----------------- |
| **롤링 배포 (Rolling Deployment)** | 서버를 순차적으로 새 버전으로 교체          | 무중단, 신/구 버전 공존    |
| **블루/그린 배포 (Blue/Green)**      | 새로운 전체 환경을 만들어두고 트래픽을 전환     | 빠른 롤백, 리소스 많이 필요  |
| **카나리 배포 (Canary Deployment)** | 전체 중 일부 사용자만 새 버전 사용 → 점진 확대 | 사용자 기반 A/B 테스트 느낌 |
| **변경 불가 배포 (Immutable)**       | 기존 서버는 그대로 두고, 새 서버에만 배포     | 위험 최소화, 느리지만 안전   |
| **트래픽 분할 배포**                  | 새 버전에 트래픽을 일정 비율만 분배         | 상태 좋으면 100%로 전환   |

## 다른 배포전략들은 언제 사용하면 좋을까?
| 전략           | 주요 목적                | 언제 적합한가?                       |
| ------------ | -------------------- | ------------------------------ |
| **롤링 배포**    | 무중단 + 서버 추가 없이 배포    | 소규모/중간 규모 서비스, 리소스 제한적일 때      |
| **블루/그린**    | 빠른 롤백 + 안정성 극대화      | 대규모 트래픽, 즉시 롤백이 필요한 서비스        |
| **카나리 배포**   | 실사용자 대상 실험 (A/B 테스트) | 위험도 높은 기능, 사용자 피드백이 중요한 경우     |
| **변경 불가 배포** | 안정성 + 불변 인프라         | 민감한 보안 환경, 오류 남기면 안 되는 시스템     |
| **트래픽 분할**   | 점진적 전환 + 트래픽 통제      | 새 버전 성능 테스트, 일부 유저만 새 기능 테스트 시 |

| 상황               | 추천 배포 전략           | 이유                  |
| ---------------- | ------------------ | ------------------- |
| 서버 적고, 돈/시간 부족   | **롤링 배포**          | EC2를 덜 쓰고 간단함       |
| 빠른 롤백, 다운타임 0 중요 | **블루/그린**          | 문제 생기면 1초 만에 트래픽 전환 |
| 실사용자 기반 A/B 실험   | **카나리**            | 기능 점검 후 단계별 확장      |
| 미션크리티컬 시스템       | **변경 불가 배포**       | 기존 서버 손대지 않음        |
| 쿠버네티스 기반 서비스     | 보통 **롤링 + 카나리** 혼합 | 설정 가능, 오토메이션 강력함    |

# 블루/그린 배포
- 블루/그린 배포는 운영중인 환경(Blue)과 새 버전 환경(Green)을 완전히 분리
- 새 버전이 준비되면 트래픽만 Green으로 순간 전환하는 배포 방식

## 장점
| 항목              | 설명                                 |
| --------------- | ---------------------------------- |
| **무중단 배포**      | 트래픽 스위치만 바꾸기 때문에 끊김 없음             |
| **즉시 롤백 가능**    | 문제가 생기면 다시 Blue로 전환하면 끝            |
| **테스트 & 검증 용이** | 실제 환경과 동일한 곳에서 Green 테스트 가능        |
| **점진적 전환 가능**   | 일부만 Green에 붙이는 것도 가능 (카나리처럼 활용 가능) |

## 단점
| 항목             | 설명                                |
| -------------- | --------------------------------- |
| **인프라 비용 증가**  | Blue + Green 환경 모두 유지해야 함 (2배 비용) |
| **상태 동기화 어려움** | DB나 세션이 공유되어야 안 끊김                |
| **배포 자동화 필요**  | 로드밸런서 전환, 헬스체크, 삭제 등 자동화가 필요함     |

## ❓Blue에서 Green으로 트래픽 전환했는데 이미 Blue에 접속해있던 사용자들은 어떻게 되나?
| 상황                   | 결과                                                     |
| -------------------- | ------------------------------------------------------ |
| 사용자가 Blue 인스턴스에 접속 중 | 👉 **세션이 유지된 채 Blue에서 요청 처리됨** (로드밸런서가 트래픽 전환 전까지는 유지) |
| 트래픽 전환 직후 새로운 요청     | 👉 이제부터는 Green 인스턴스로 연결됨                               |
| Blue 환경 인스턴스가 꺼진다면   | 👉 **세션이 끊기거나, 오류 발생 가능성**                             |

## 이를 방지하는 실무 대응 전략

### 1️⃣ 로드밸런서 “드레이닝(Draining)” 모드 사용
- 로드밸런서가 Blue 인스턴스를 즉시 죽이지 않고, 기존 연결은 끝까지 처리한 뒤에 종료하는 방식
- 이미 Blue에 붙은 사용자는 끝까지 거기서 서비스 받고, 새로오는 요청만 Green으로 보냄

### 2️⃣ 세션 공유 또는 외부 세션 저장소 사용
- 사용자가 Blue -> Green으로 넘어가도 세션이 유지되게 하기 위해 세션 정보를 DB, Redis 같은 외부 저장소에 보관

### 3️⃣ Sticky Session 사용 (선택적)
- 로드밸런서가 사용자의 요청을 항상 같은 인스턴스로 연결
- 사용자가 접속한 인스턴스를 계속 유지하게 만듦

### 4️⃣ 전환 지연 설정 
- 처음부터 전체 트래픽을 전환하지 않고 일부만 Green으로 보내면 문제가 있어도 Blue 사용자에게 영향 없음

### 요약
| 문제                     | 대응 방법                                  |
| ---------------------- | -------------------------------------- |
| 이미 Blue에 접속한 사용자 연결 유지 | ✔️ 로드밸런서 드레이닝 (연결 유지 후 종료)             |
| 세션이 끊길 위험              | ✔️ 외부 세션 저장소 사용 (Redis 등)              |
| 트래픽 전환 중 사용자 경험 불안정    | ✔️ 점진 전환 / Sticky Session / A/B 테스트 전략 |

## ❓Blue에 붙은 사용자가 접속을 평생 안끊으면?
- 세션 타임아웃 설정
  - 일반적으로 세션 만료 시간을 설정함
  - 세션이 만료되면 로그인페이지로 보내거나 재접속 필요 -> 자동을 Green 환경에 붙게된다.
- 인스턴스 종료 강제
  - Blue 인스턴스는 일정 시간을 두고 강제 종료되도록 스크립트나 배포 툴이 제어
  - 기존 연결을 전부 끊고 강제 세션 종료 -> 모든 사용자가 Green으로 넘어가게됨
- 드레이닝 타임 제한 (로드밸런서 설정)
  - ELB(ALB)는 드레이닝 모드에 최대 대기 시간 설정 가능
- 사용자 단에 제한 걸기
  - 클리언트 앱에도 세션 유지 정책 설정

## ❓드레이닝 (Draining)
- 인스턴스를 바로 종료하지 않고, 기존 연결이 끝날 때까지 기다려주는 중간 상태

## ❓ELB / ALB
### ELB (Elastic Load Balancer)
- AWS의 트래픽 분산기 - 여러 인스턴스에 자동으로 트래픽을 분배하는 서비스

### ELB의 종류
| 종류      | 정식 명칭                       | 설명                                    |
| ------- | --------------------------- | ------------------------------------- |
| **ALB** | Application Load Balancer   | 💡 가장 자주 쓰이는 타입 – URL 기반 라우팅 가능       |
| **NLB** | Network Load Balancer       | TCP 레벨 처리에 적합 – 초고속 트래픽, 실시간 게임 등에 사용 |
| **CLB** | Classic Load Balancer (구버전) | 오래된 방식, 새 프로젝트엔 ALB/NLB 권장            |

